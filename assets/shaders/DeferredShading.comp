#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_nonuniform_qualifier : require

#include "Material.glsl"
#include "UniformBufferObject.glsl"

layout(binding = 0, r32ui) uniform uimage2D MiniGBuffer;
layout(binding = 1, rgba8) uniform image2D OutImage;
layout(binding = 2) readonly uniform UniformBufferObjectStruct { UniformBufferObject Camera; };
layout(binding = 3) uniform sampler2D[] TextureSamplers;
layout(binding = 4) readonly buffer VertexArray { float Vertices[]; };
layout(binding = 5) readonly buffer IndexArray { uint Indices[]; };
layout(binding = 6) readonly buffer MaterialArray { Material[] Materials; };
layout(binding = 7) readonly buffer OffsetArray { uvec2[] Offsets; };

#include "Vertex.glsl"
//layout(push_constant) uniform PushConsts {
//    uint pingpong;
//    uint stepsize;
//} pushConsts;

layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;

Vertex get_material_data(ivec2 pixel, uint primitive_index, vec3 ray_origin , vec3 ray_direction)
{
    Vertex result;
    vec3 positions[3], normals[3];
	vec2 tex_coords[3];
	int matid;
	
	for (int i = 0; i != 3; ++i) {
		uint vertex_index = primitive_index * 3 + i;
		const Vertex v = UnpackVertex(vertex_index);
		positions[i] = v.Position;
		normals[i] = v.Normal;
		tex_coords[i] = v.TexCoord;
		matid = v.MaterialIndex;
	}
	
	vec3 barycentrics;
	vec3 edges[2] = {
		positions[1] - positions[0],
		positions[2] - positions[0]
	};
	
	vec3 ray_cross_edge_1 = cross(ray_direction, edges[1]);
	float rcp_det_edges_direction = 1.0f / dot(edges[0], ray_cross_edge_1);
	vec3 ray_to_0 = ray_origin - positions[0];
	float det_0_dir_edge_1 = dot(ray_to_0, ray_cross_edge_1);
	barycentrics.y = rcp_det_edges_direction * det_0_dir_edge_1;
	vec3 edge_0_cross_0 = cross(edges[0], ray_to_0);
	float det_dir_edge_0_0 = dot(ray_direction, edge_0_cross_0);
	barycentrics.z = -rcp_det_edges_direction * det_dir_edge_0_0;
	barycentrics.x = 1.0f - (barycentrics.y + barycentrics.z);
	
	result.Position = fma(vec3(barycentrics[0]), positions[0], fma(vec3(barycentrics[1]), positions[1], barycentrics[2] * positions[2]));
	result.Normal = normalize(fma(vec3(barycentrics[0]), normals[0], fma(vec3(barycentrics[1]), normals[1], barycentrics[2] * normals[2])));
	result.TexCoord = fma(vec2(barycentrics[0]), tex_coords[0], fma(vec2(barycentrics[1]), tex_coords[1], barycentrics[2] * tex_coords[2]));
	result.MaterialIndex = matid;
	
	return result;
}


void main() {

    // checker box
    int adder = Camera.TotalFrames % 2 == 0 ? 1 : 0;
    
    ivec2 ipos = ivec2(gl_GlobalInvocationID.xy) * ivec2(2,1);
    if((gl_GlobalInvocationID.y + adder) % 2 == 0) {
        ipos.x += 1;
    }
	
	ivec2 size = imageSize(MiniGBuffer);
    uint primitive_index = imageLoad(MiniGBuffer, ipos).r;
    vec2 uv = vec2(ipos) / vec2(size) * 2.0 - 1.0;
    vec4 origin = Camera.ModelViewInverse * vec4(0, 0, 0, 1);
	vec4 target = Camera.ProjectionInverse * (vec4(uv.x, uv.y, 1, 1));
	vec4 dir = Camera.ModelViewInverse * vec4(normalize(target.xyz), 0);
    
    Vertex v = get_material_data(ipos, primitive_index, origin.xyz, normalize(dir.xyz));
    
    Material mat = Materials[v.MaterialIndex];
    vec4 albedo = mat.Diffuse;
    if (mat.DiffuseTextureId >= 0)
    {
        vec4 tex = texture(TextureSamplers[mat.DiffuseTextureId], v.TexCoord);
        albedo *= tex * tex;
    }
	
    const vec3 lightVector = normalize(vec3(5, 4, 3));
    const float d = max(dot(lightVector, normalize(v.Normal.rgb)), 0.2);
    
    vec4 outColor = sqrt(albedo * d);
    imageStore(OutImage, ipos, outColor);
}