#version 460
#extension GL_GOOGLE_include_directive : require
#include "Platform.glsl"
#include "UniformBufferObject.glsl"

layout(binding = 0, rgba16f) uniform image2D NewSourceImage;
layout(binding = 1, rgba16f) uniform image2D AccumulateImage;
layout(binding = 2, rgba16f) uniform image2D Accumulate1Image;
layout(binding = 3, rg16f) uniform image2D MotionVectorImage;
layout(binding = 4) readonly uniform UniformBufferObjectStruct { UniformBufferObject Camera; };

layout(binding = 5, r32ui) uniform uimage2D VisibilityBuffer;
layout(binding = 6, r32ui) uniform uimage2D Visibility1Buffer;
layout(binding = 7, rgba8) uniform image2D OutImage;

layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;


vec3 LinearToST2084UE(vec3 lin)
{
    const float m1 = 0.1593017578125; // = 2610. / 4096. * .25;
    const float m2 = 78.84375; // = 2523. / 4096. *  128;
    const float c1 = 0.8359375; // = 2392. / 4096. * 32 - 2413./4096.*32 + 1;
    const float c2 = 18.8515625; // = 2413. / 4096. * 32;
    const float c3 = 18.6875; // = 2392. / 4096. * 32;
    const float C = 10000.;

    vec3 L = lin/C;
    vec3 Lm = pow(L, vec3(m1));
    vec3 N1 = ( c1 + c2 * Lm );
    vec3 N2 = ( 1.0 + c3 * Lm );
    vec3 N = N1 * (1.0 / N2);
    vec3 P = pow( N, vec3(m2) );

    return P;
}

// a simple accumulation shader, reproject can impl here later.
void main() {
    ivec2 ipos = ivec2(gl_GlobalInvocationID.xy);

    vec2 motion = imageLoad(MotionVectorImage, ipos).rg;
    vec4 src = imageLoad(NewSourceImage, ipos);
    
    vec2 prevfpos = vec2(ipos) + motion;
    ivec2 previpos = ivec2( floor(ipos + motion) );
    vec2 subpixel = fract(prevfpos);

    vec4 history0 = Camera.TotalFrames % 2 == 0 ? imageLoad(AccumulateImage, previpos) : imageLoad(Accumulate1Image, previpos);
    vec4 history1 = Camera.TotalFrames % 2 == 0 ? imageLoad(AccumulateImage, previpos + ivec2(1,0)) : imageLoad(Accumulate1Image, previpos + ivec2(1,0));
    vec4 history2 = Camera.TotalFrames % 2 == 0 ? imageLoad(AccumulateImage, previpos + ivec2(0,1)) : imageLoad(Accumulate1Image, previpos + ivec2(0,1));
    vec4 history3 = Camera.TotalFrames % 2 == 0 ? imageLoad(AccumulateImage, previpos + ivec2(1,1)) : imageLoad(Accumulate1Image, previpos + ivec2(1,1));
    
    
    vec4 history = mix(
        mix(history0, history1, subpixel.x),
        mix(history2, history3, subpixel.x),
        subpixel.y
    );
    
    // find the min color of 4 history
    vec4 history_min = min(history, min(history0, min(history1, min(history2, history3))));
    // then the max
    vec4 history_max = max(history, max(history0, max(history1, max(history2, history3))));
    
    // that may bilinear to peak value, try to clamp it the color clampbox
    history = clamp(history, history_min, history_max);
    
    // clamp the history color
    //history = clamp(history, vec4(0.0), vec4(1.25));
    
    // fetch visibility to validate the history
    if( length(motion) > 0.5 )
    {
        uint current_primitive_index = imageLoad(VisibilityBuffer, ipos).r;
        uint prev_primitive_index0 = imageLoad(Visibility1Buffer, previpos).r;
        uint prev_primitive_index1 = imageLoad(Visibility1Buffer, previpos + ivec2(1,0)).r;
        uint prev_primitive_index2 = imageLoad(Visibility1Buffer, previpos + ivec2(0,1)).r;
        uint prev_primitive_index3 = imageLoad(Visibility1Buffer, previpos + ivec2(1,1)).r;

        bool miss = any( notEqual( uvec4(prev_primitive_index0, prev_primitive_index1, prev_primitive_index2, prev_primitive_index3), uvec4(current_primitive_index) ));

        if( miss )
        {
            history = src;
        }
    }

    // save to 
    uint primitive_index = imageLoad(VisibilityBuffer, ipos).r;
    if(primitive_index == 0)
    {
        history = src;
    }
    imageStore(Visibility1Buffer, ipos, ivec4(primitive_index,0,0,0));
   
    // the prev pos should bilinear sample cause it may int subpixel
    
    
    // judge current gbuffer / object id with prev frame, to deghosting
    
    float currKeep = 1.0 / max(1, Camera.TemporalFrames);

    if(Camera.TotalFrames == 0)
    {
         history = src;
    }
    
    vec4 final = mix(history, src, currKeep);
    if(Camera.TotalFrames % 2 == 0 )
    {
        imageStore(Accumulate1Image, ipos, final);
    }
    else
    {
        imageStore(AccumulateImage, ipos, final);
    }
    
    // directly output
    #if DESKTOP
    imageStore(OutImage, ipos, vec4( LinearToST2084UE(final.rgb * Camera.PaperWhiteNit / 230.0), 1.0));
    #else
    imageStore(OutImage, ipos, vec4( pow(LinearToST2084UE(final.rgb * Camera.PaperWhiteNit / 230.0),vec3(2.0)) * 2.0, 1.0));
    #endif
}