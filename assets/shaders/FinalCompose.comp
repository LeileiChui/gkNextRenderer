#version 460
#extension GL_GOOGLE_include_directive : require

#include "common/UniformBufferObject.glsl"
#include "common/ColorFunc.glsl"

layout(binding = 0, rgba16f) uniform image2D InImage;
layout(binding = 1, rgba8) uniform image2D OutImage;
layout(binding = 2) readonly uniform UniformBufferObjectStruct { UniformBufferObject Camera; };

// use for jbf
layout(binding = 3, rgba16f) uniform image2D InAlbedo;
layout(binding = 4, rgba16f) uniform image2D InNormal;
layout(binding = 5, r32ui) uniform uimage2D InVisibility0;
layout(binding = 6, r32ui) uniform uimage2D InVisibility1;

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

const int WORK_GROUP_AXIS_SIZE = 16;
const int WINDOW_R = 3;
const int WINDOW_LEN = WORK_GROUP_AXIS_SIZE + 2 * WINDOW_R;

shared vec3 window[WINDOW_LEN][WINDOW_LEN];

void main() {

    const ivec2 ipos = ivec2(gl_GlobalInvocationID.xy) + ivec2(Camera.ViewportRect.x, Camera.ViewportRect.y);
    bool isEvenFrame = Camera.TotalFrames % 2 == 0 ? true : false;

    vec3 Total = vec3(0);
    
   
    if(Camera.BFSize > 0)
    {
        // share memory
        if( false )
        {
            int row = int(gl_LocalInvocationIndex / WINDOW_LEN);
            int col = int(gl_LocalInvocationIndex % WINDOW_LEN);
            ivec2 coord = ivec2(gl_WorkGroupID.xy) * WORK_GROUP_AXIS_SIZE + ivec2(col - WINDOW_R, row - WINDOW_R);
            window[row][col] = imageLoad(InImage, coord).rgb;

            int idx = int(gl_LocalInvocationIndex + WORK_GROUP_AXIS_SIZE * WORK_GROUP_AXIS_SIZE);
            if (idx < WINDOW_LEN * WINDOW_LEN)
            {
                row = idx / WINDOW_LEN;
                col = idx % WINDOW_LEN;
                coord = ivec2(gl_WorkGroupID.xy) * WORK_GROUP_AXIS_SIZE + ivec2(col - WINDOW_R, row - WINDOW_R);
                window[row][col] = imageLoad(InImage, coord).rgb;
            }

            barrier();

            coord = ivec2(gl_LocalInvocationID.xy) + WINDOW_R;
            vec3 sum = window[coord.y][coord.x];
            float sum_w = 1.0, texel_w;
            
            for (int i = -WINDOW_R; i <= WINDOW_R; ++i)
            {
                for (int j = -WINDOW_R; j <= WINDOW_R; ++j)
                {
                    if (i != 0 || j != 0)
                    {
                        sum += window[coord.y + i][coord.x + j];
                        sum_w += 1.0;
                    }
                }
            }

            Total = sum / sum_w;
            //Total = imageLoad(InImage, ipos).rgb;
        }
        else
        {
            // simple joint bilateral filter
            const int N = int(Camera.BFSize); // filter size
            const float sigma = Camera.BFSigma; // spatial sigma
            const float sigmaL = Camera.BFSigmaLum * 100.0; // 
            const float sigmaN = Camera.BFSigmaNormal;
            const int SX = 1; // spatial step
            const int SY = 1; // spatial step

            const vec3 CenterColor = imageLoad(InImage, ipos).rgb;
            const vec3 CenterAlbedo = imageLoad(InAlbedo, ipos).rgb + vec3(0.001,0.001,0.001);
            const vec3 DemodulateColor = CenterColor / CenterAlbedo;

            const vec3 Normal = imageLoad(InNormal, ipos).rgb;
            uint current_primitive_index = isEvenFrame ? imageLoad(InVisibility0, ipos).r : imageLoad(InVisibility1, ipos).r;

            const float CenterLum = dot(DemodulateColor, vec3(0.212671F, 0.715160F, 0.072169F));

            float Weight = 0;

            int c,d;
            for(c=-N;c<N+1;c++)
            {
                for(d=-N;d<N+1;d++)
                {
                    const vec3 Ci = imageLoad(InImage, ipos + ivec2(c*SX,d*SY)).rgb / (imageLoad(InAlbedo, ipos + ivec2(c*SX,d*SY)).rgb + vec3(0.001,0.001,0.001));

                    const vec3 Ni = imageLoad(InNormal, ipos + ivec2(c*SX,d*SY)).rgb;
                    const uint Pi = isEvenFrame ? imageLoad(InVisibility0, ipos + ivec2(c*SX,d*SY)).r : imageLoad(InVisibility1, ipos + ivec2(c*SX,d*SY)).r;
                    const float lumi = dot((Ci), vec3(0.212671F, 0.715160F, 0.072169F));


                    const float dist = clamp( float(c*c+d*d)/float(N*N) , 0., 1. );
                    const float normaldist = 1.0 - dot(Ni, Normal);
                    const float dlum = (CenterLum - lumi)*(CenterLum - lumi);

                    const float Fi = exp(-dist*dist/(2.* sigma*sigma));
                    const float Ai = exp(-normaldist*normaldist/(2.* sigmaN*sigmaN));
                    const float Li = exp(-dlum*dlum/(2.* sigmaL*sigmaL));
                    const float Oi = float(current_primitive_index == Pi);

                    Total += Ci * Fi * Li * Ai * Oi;
                    Weight += Fi * Li * Ai * Oi;
                }
            }
            Total /= Weight;

            Total = Total * CenterAlbedo;
        }
    }
    else
    {
        Total = imageLoad(InImage, ipos).rgb;
    }
    
    if(Camera.HDR)
    {
        imageStore(OutImage, ipos, vec4( LinearToST2084UE( Total * Camera.PaperWhiteNit / 230.0), 1.0));
    }
    else
    {
        imageStore(OutImage, ipos, vec4( Uncharted2_Tonemapping( Total * Camera.PaperWhiteNit / 20000.0), 1.0));
    }
}