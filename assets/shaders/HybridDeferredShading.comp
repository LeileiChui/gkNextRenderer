#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_ray_query : require

#include "Platform.glsl"
#include "Material.glsl"
#include "UniformBufferObject.glsl"
#include "Random.glsl"

layout(binding = 0, rg32ui) uniform uimage2D MiniGBuffer;
layout(binding = 1, rgba8) uniform image2D OutImage;
layout(binding = 2) readonly uniform UniformBufferObjectStruct { UniformBufferObject Camera; };
layout(binding = 3) uniform sampler2D[] TextureSamplers;
layout(binding = 4) readonly buffer VertexArray { float Vertices[]; };
layout(binding = 5) readonly buffer IndexArray { uint Indices[]; };
layout(binding = 6) readonly buffer MaterialArray { Material[] Materials; };
layout(binding = 7) readonly buffer OffsetArray { uvec2[] Offsets; };
layout(binding = 8) readonly buffer NodeProxyArray { NodeProxy[] NodeProxies; };
layout(binding = 9, rg16f) uniform image2D OutMotionVector;
layout(binding = 10, set = 0) uniform accelerationStructureEXT Scene;
layout(binding = 11, rgba16f) uniform image2D InOutDirectLight0;
layout(binding = 12, rgba16f) uniform image2D InOutDirectLight1;

#include "Vertex.glsl"

#if DESKTOP
layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;
#else
layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;
#endif

//-----------------------------------------------------------------------------
struct RayPayload
	//-----------------------------------------------------------------------------
{
	// Flag for hit or miss
	uint    IsHit;

	// Geometry instance ids
	int     PrimitiveIndex;
	int     InstanceID;
	int     InstCustIndex;
	// in     int   gl_GeometryIndexEXT;

	// World space parameters
	vec3   RayOrigin;
	vec3   RayDirection;

	// Ray hit info
	float  HitDist;
	uint   IsFrontFacing;

	// Barycentric Coordinates
	vec3    BaryCoords;
};

vec2 Mix(vec2 a, vec2 b, vec2 c, vec3 barycentrics)
{
	return a * barycentrics.x + b * barycentrics.y + c * barycentrics.z;
}

vec3 Mix(vec3 a, vec3 b, vec3 c, vec3 barycentrics)
{
	return a * barycentrics.x + b * barycentrics.y + c * barycentrics.z;
}

Vertex get_material_data(ivec2 pixel, uvec2 vBuffer, vec3 ray_origin , vec3 ray_direction)
{
	uint instance_index = vBuffer.x;
	uint triangle_index = vBuffer.y;

	NodeProxy proxy = NodeProxies[instance_index];
	
    Vertex result;
    vec3 positions[3], normals[3];
	vec2 tex_coords[3];
	int matid;
	
	for (int i = 0; i != 3; ++i) {
		uint vertex_index = triangle_index * 3 + i;
		const Vertex v = UnpackVertex(vertex_index);
		positions[i] = (proxy.World * vec4(v.Position, 1)).xyz;
		normals[i] = (proxy.World * vec4(v.Normal, 0)).xyz;
		tex_coords[i] = v.TexCoord;
		matid = v.MaterialIndex;
	}
	
	vec3 barycentrics;
	vec3 edges[2] = {
		positions[1] - positions[0],
		positions[2] - positions[0]
	};
	
	vec3 ray_cross_edge_1 = cross(ray_direction, edges[1]);
	float rcp_det_edges_direction = 1.0f / dot(edges[0], ray_cross_edge_1);
	vec3 ray_to_0 = ray_origin - positions[0];
	float det_0_dir_edge_1 = dot(ray_to_0, ray_cross_edge_1);
	barycentrics.y = rcp_det_edges_direction * det_0_dir_edge_1;
	vec3 edge_0_cross_0 = cross(edges[0], ray_to_0);
	float det_dir_edge_0_0 = dot(ray_direction, edge_0_cross_0);
	barycentrics.z = -rcp_det_edges_direction * det_dir_edge_0_0;
	barycentrics.x = 1.0f - (barycentrics.y + barycentrics.z);
	
	result.Position = fma(vec3(barycentrics[0]), positions[0], fma(vec3(barycentrics[1]), positions[1], barycentrics[2] * positions[2]));
	result.Normal = normalize(fma(vec3(barycentrics[0]), normals[0], fma(vec3(barycentrics[1]), normals[1], barycentrics[2] * normals[2])));
	result.TexCoord = fma(vec2(barycentrics[0]), tex_coords[0], fma(vec2(barycentrics[1]), tex_coords[1], barycentrics[2] * tex_coords[2]));
	result.MaterialIndex = matid;
	
	return result;
}

vec3 get_position(ivec2 pixel, uvec2 vBuffer, vec3 ray_origin , vec3 ray_direction)
{
	uint instance_index = vBuffer.x;
	uint triangle_index = vBuffer.y;

	NodeProxy proxy = NodeProxies[instance_index];
	
	vec3 positions[3];
	
	for (int i = 0; i != 3; ++i) {
		uint vertex_index = triangle_index * 3 + i;
		const Vertex v = UnpackVertex(vertex_index);
		positions[i] = (proxy.World * vec4(v.Position, 1.0)).xyz;
	}

	vec3 barycentrics;
	vec3 edges[2] = {
	positions[1] - positions[0],
	positions[2] - positions[0]
	};

	vec3 ray_cross_edge_1 = cross(ray_direction, edges[1]);
	float rcp_det_edges_direction = 1.0f / dot(edges[0], ray_cross_edge_1);
	vec3 ray_to_0 = ray_origin - positions[0];
	float det_0_dir_edge_1 = dot(ray_to_0, ray_cross_edge_1);
	barycentrics.y = rcp_det_edges_direction * det_0_dir_edge_1;
	vec3 edge_0_cross_0 = cross(edges[0], ray_to_0);
	float det_dir_edge_0_0 = dot(ray_direction, edge_0_cross_0);
	barycentrics.z = -rcp_det_edges_direction * det_dir_edge_0_0;
	barycentrics.x = 1.0f - (barycentrics.y + barycentrics.z);

	return fma(vec3(barycentrics[0]), positions[0], fma(vec3(barycentrics[1]), positions[1], barycentrics[2] * positions[2]));
}

// The helper for the equirectangular textures.
vec4 equirectangularSample(vec3 direction, float rotate)
{
	const float pi = 3.1415926535897932384626433832795;
	vec3 d = normalize(direction);
	vec2 t = vec2((atan(d.x, d.z) + pi * rotate) / (2.f * pi), acos(d.y) / pi);

	return min( vec4(10,10,10,1), texture(TextureSamplers[0], t));
}

float Schlick(const float cosine, const float refractionIndex)
{
	float r0 = (1 - refractionIndex) / (1 + refractionIndex);
	r0 *= r0;
	return r0 + (1 - r0) * pow(1 - cosine, 5);
}

vec3 TraceRay(ivec2 ipos, vec3 origin, vec3 direction, vec3 iblColor, inout vec3 bounceColor)
{
	rayQueryEXT rayQuery;
	rayQueryInitializeEXT(rayQuery, Scene, gl_RayFlagsNoneEXT, 0xFF, origin, 0.01, direction, 100.0);
	rayQueryProceedEXT(rayQuery);
	if (rayQueryGetIntersectionTypeEXT(rayQuery, true) == gl_RayQueryCommittedIntersectionTriangleEXT  ) {
		RayPayload PayloadData;

		const bool IsCommitted = true;

		PayloadData.PrimitiveIndex = rayQueryGetIntersectionPrimitiveIndexEXT(rayQuery, IsCommitted);
		PayloadData.InstanceID = rayQueryGetIntersectionInstanceIdEXT(rayQuery, IsCommitted);
		PayloadData.InstCustIndex = rayQueryGetIntersectionInstanceCustomIndexEXT(rayQuery, IsCommitted);
		// in     int   gl_GeometryIndexEXT;

		// World space parameters
		PayloadData.RayOrigin  = rayQueryGetWorldRayOriginEXT(rayQuery);
		PayloadData.RayDirection = rayQueryGetWorldRayDirectionEXT(rayQuery);

		// Ray hit info
		// const uint gl_HitKindFrontFacingTriangleEXT = 0xFEU;
		// const uint gl_HitKindBackFacingTriangleEXT = 0xFFU;
		PayloadData.HitDist = rayQueryGetIntersectionTEXT(rayQuery, IsCommitted);
		PayloadData.IsFrontFacing = 1;
		bool IsFrontFacing = rayQueryGetIntersectionFrontFaceEXT(rayQuery, IsCommitted);
		if(!IsFrontFacing)
		PayloadData.IsFrontFacing = 0;

		mat4x3 worldtoobject = rayQueryGetIntersectionWorldToObjectEXT(rayQuery, IsCommitted);

		// Barycentric Coordinates
		// Floating point barycentric coordinates of current intersection of ray.
		// Three Barycentric coordinates are such that their sum is 1.
		// This gives only two and expects us to calculate the third
		vec2 TwoBaryCoords = rayQueryGetIntersectionBarycentricsEXT(rayQuery, IsCommitted);
		PayloadData.BaryCoords = vec3(1.0 - TwoBaryCoords.x - TwoBaryCoords.y, TwoBaryCoords.x, TwoBaryCoords.y);

		const uvec2 offsets = Offsets[PayloadData.InstCustIndex];
		const uint indexOffset = offsets.x;
		const uint vertexOffset = offsets.y;
		const Vertex v0 = UnpackVertex(vertexOffset + Indices[indexOffset + PayloadData.PrimitiveIndex * 3 + 0]);
		const Vertex v1 = UnpackVertex(vertexOffset + Indices[indexOffset + PayloadData.PrimitiveIndex * 3 + 1]);
		const Vertex v2 = UnpackVertex(vertexOffset + Indices[indexOffset + PayloadData.PrimitiveIndex * 3 + 2]);
		const Material material = Materials[v0.MaterialIndex];

		const vec3 localNormal = Mix(v0.Normal, v1.Normal, v2.Normal, PayloadData.BaryCoords);
		const vec3 normal = normalize((localNormal * worldtoobject).xyz);
		const vec2 texCoord = Mix(v0.TexCoord, v1.TexCoord, v2.TexCoord, PayloadData.BaryCoords);

		const vec4 texColor = material.DiffuseTextureId >= 0 ? texture(TextureSamplers[nonuniformEXT(material.DiffuseTextureId)], texCoord) : vec4(1);
		
		// may get from previous frame, if not, use the albedo and force lose a magic energy
		bounceColor = texColor.rgb * material.Diffuse.rgb * iblColor * 0.8;
		
		vec3 hitPos = origin + direction * PayloadData.HitDist;
		vec4 hpos =  Camera.PrevViewProjection * vec4(hitPos, 1);
		ivec2 size = imageSize(MiniGBuffer);
		ivec2 ipos_new = ivec2((hpos.xy / hpos.w * 0.5 + 0.5) * size);
		if(ipos_new.x < 0 || ipos_new.y < 0 || ipos_new.x > size.x || ipos_new.y > size.y || hpos.z / hpos.w < 0)
		{
			return vec3(0);
		}
		if(Camera.TotalFrames % 2 == 0 )
		{
			bounceColor = imageLoad(InOutDirectLight1, ipos_new).rgb;
		}
		else
		{
			bounceColor = imageLoad(InOutDirectLight0, ipos_new).rgb;
		}
		return vec3(0);
	}
	return vec3(1);
}


// hsv to rgb
vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

vec3 LinearToST2084UE(vec3 lin)
{
	const float m1 = 0.1593017578125; // = 2610. / 4096. * .25;
	const float m2 = 78.84375; // = 2523. / 4096. *  128;
	const float c1 = 0.8359375; // = 2392. / 4096. * 32 - 2413./4096.*32 + 1;
	const float c2 = 18.8515625; // = 2413. / 4096. * 32;
	const float c3 = 18.6875; // = 2392. / 4096. * 32;
	const float C = 10000.;

	vec3 L = lin/C;
	vec3 Lm = pow(L, vec3(m1));
	vec3 N1 = ( c1 + c2 * Lm );
	vec3 N2 = ( 1.0 + c3 * Lm );
	vec3 N = N1 * (1.0 / N2);
	vec3 P = pow( N, vec3(m2) );

	return P;
}

void main() {

    // checker box
    int adder = Camera.TotalFrames % 2 == 0 ? 1 : 0;
    
    ivec2 ipos = ivec2(gl_GlobalInvocationID.xy);
    if(Camera.UseCheckerBoard)
    {
        ipos = ipos * ivec2(2,1);
        if((gl_GlobalInvocationID.y + adder) % 2 == 0) {
            ipos.x += 1;
        }
    }
	
	ivec2 size = imageSize(MiniGBuffer);
    uvec2 vBuffer = imageLoad(MiniGBuffer, ipos).rg;
    vec2 uv = vec2(ipos) / vec2(size) * 2.0 - 1.0;
    vec4 origin = Camera.ModelViewInverse * vec4(0, 0, 0, 1);
	vec4 target = Camera.ProjectionInverse * (vec4(uv.x, uv.y, 1, 1));
	vec4 dir = Camera.ModelViewInverse * vec4(normalize(target.xyz), 0);
	
	// x == y == 0, hit the sky, quick go
	if(vBuffer.x == 0)
	{
		imageStore(OutImage, ipos, vec4(0));
		imageStore(OutMotionVector, ipos, vec4(0));
		return;
	}
	
	vBuffer.x = vBuffer.x - 1;
	
	vec3 ray_dir = normalize(dir.xyz);
    
    Vertex v = get_material_data(ipos, vBuffer, origin.xyz, ray_dir);
    
    Material mat = Materials[v.MaterialIndex];
    vec4 albedo = mat.Diffuse;
    if (mat.DiffuseTextureId >= 0)
    {
        vec4 tex = texture(TextureSamplers[mat.DiffuseTextureId], v.TexCoord);
        albedo *= tex * tex;
    }
	
	vec3 normal = normalize( v.Normal.rgb);
	
	// ibl
	const float dotValue = dot(ray_dir, normal);
	const vec3 outwardNormal = dotValue > 0 ? -normal : normal;
	const float cosine = dotValue > 0 ? mat.RefractionIndex * dotValue : -dotValue;
	const float reflectProb = Schlick(cosine, mat.RefractionIndex);
	const float metalProb = mat.Metalness;
	
	
	vec3 skyColor = vec3(1);
	vec3 bounceColor = vec3(0);
	
	uint RandomSeed = InitRandomSeed(InitRandomSeed(ipos.x, ipos.y), Camera.TotalFrames);
	if(true)
	{
		vec3 trace_dir = RandomFloat(RandomSeed) < reflectProb ?
		AlignWithNormal( RandomInCone(RandomSeed, cos(mat.Fuzziness * 45.f / 180.f * 3.14159f)), reflect( ray_dir, outwardNormal) ) :
		( RandomFloat(RandomSeed) < metalProb ?
		AlignWithNormal( RandomInCone(RandomSeed, cos(mat.Fuzziness * 45.f / 180.f * 3.14159f)), reflect( ray_dir, outwardNormal) ) :
		AlignWithNormal( RandomInHemiSphere(RandomSeed), outwardNormal )
		);
		
		// if miss, sample the sky
		vec3 iblColor = equirectangularSample(trace_dir, Camera.SkyRotation).rgb * 1000.0;
		vec3 hitColor = TraceRay(ipos, v.Position, trace_dir, iblColor, bounceColor);
		skyColor = iblColor * hitColor;
	}
	else
	{
		const float t = 0.5*(v.Normal.y + 1);
		skyColor = mix(vec3(1.0), vec3(0.5, 0.7, 1.0) * 20, t);
	}

    vec4 outColor = albedo * vec4(skyColor,1);
    
    if(Camera.HasSun)
    {
    	const vec3 lightVector = Camera.SunDirection.xyz;
		vec3 d = max(dot(lightVector, normalize(v.Normal.rgb)),0.0) * Camera.SunColor.xyz;
        
        d = mix(d, vec3(0.0), vec3(metalProb));
    
        const vec3 lightVectorCone = AlignWithNormal( RandomInCone(RandomSeed, cos(0.5f / 180.f * 3.14159f)), lightVector);
        
        rayQueryEXT rayQuery;
        rayQueryInitializeEXT(rayQuery, Scene, gl_RayFlagsTerminateOnFirstHitEXT, 0xFF, v.Position.xyz, 0.01, lightVectorCone, 10000.0);
        rayQueryProceedEXT(rayQuery);
        if (rayQueryGetIntersectionTypeEXT(rayQuery, true) == gl_RayQueryCommittedIntersectionTriangleEXT  ) {
            d = vec3(0.0);
        }
        outColor.rgb += albedo.rgb * d;
    }
	
	vec4 directLight = vec4(outColor.rgb, 1);

	if(Camera.TotalFrames % 2 == 0 )
	{
		imageStore(InOutDirectLight0, ipos, directLight);
	}
	else
	{
		imageStore(InOutDirectLight1, ipos, directLight);
	}
	
	
	outColor.rgb += albedo.rgb * bounceColor.rgb;
	
    imageStore(OutImage, ipos, outColor);
    
    	// calculate the motion vector
	vec4 currFrameHPos = Camera.ViewProjection * vec4(v.Position, 1);
	vec2 currfpos = vec2((currFrameHPos.xy / currFrameHPos.w * 0.5 + 0.5) * vec2(size));

	vec4 prevFrameHPos = Camera.PrevViewProjection * vec4(v.Position, 1);
	vec2 prevfpos = vec2((prevFrameHPos.xy / prevFrameHPos.w * 0.5 + 0.5) * vec2(size));
	vec2 motion = prevfpos - currfpos;
	imageStore(OutMotionVector, ipos, vec4(motion,0,0));
}