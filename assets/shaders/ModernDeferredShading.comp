#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_nonuniform_qualifier : require

#include "Material.glsl"
#include "UniformBufferObject.glsl"
#include "Random.glsl"

layout(binding = 0, rg32ui) uniform uimage2D MiniGBuffer;
layout(binding = 1, rgba8) uniform image2D OutImage;
layout(binding = 2) readonly uniform UniformBufferObjectStruct { UniformBufferObject Camera; };
layout(binding = 3) uniform sampler2D[] TextureSamplers;
layout(binding = 4) readonly buffer VertexArray { float Vertices[]; };
layout(binding = 5) readonly buffer IndexArray { uint Indices[]; };
layout(binding = 6) readonly buffer MaterialArray { Material[] Materials; };
layout(binding = 7) readonly buffer OffsetArray { uvec2[] Offsets; };
layout(binding = 8) readonly buffer NodeProxyArray { NodeProxy[] NodeProxies; };
layout(binding = 9, rg16f) uniform image2D OutMotionVector;

#include "Vertex.glsl"
//layout(push_constant) uniform PushConsts {
//    uint pingpong;
//    uint stepsize;
//} pushConsts;

layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;

Vertex get_material_data(ivec2 pixel, uvec2 vBuffer, vec3 ray_origin , vec3 ray_direction)
{
	// fetch primitive_index high 14bit as instance index and low 18bit as triangle index
	uint instance_index = vBuffer.y;
	uint triangle_index = vBuffer.x;

	NodeProxy proxy = NodeProxies[instance_index];
	
    Vertex result;
    vec3 positions[3], normals[3];
	vec2 tex_coords[3];
	int matid;
	
	for (int i = 0; i != 3; ++i) {
		uint vertex_index = triangle_index * 3 + i;
		const Vertex v = UnpackVertex(vertex_index);
		positions[i] = (proxy.World * vec4(v.Position, 1)).xyz;
		normals[i] = (proxy.World * vec4(v.Normal, 0)).xyz;
		tex_coords[i] = v.TexCoord;
		matid = v.MaterialIndex;
		
		// localspace, need transfer
		 
	}
	
	vec3 barycentrics;
	vec3 edges[2] = {
		positions[1] - positions[0],
		positions[2] - positions[0]
	};
	
	vec3 ray_cross_edge_1 = cross(ray_direction, edges[1]);
	float rcp_det_edges_direction = 1.0f / dot(edges[0], ray_cross_edge_1);
	vec3 ray_to_0 = ray_origin - positions[0];
	float det_0_dir_edge_1 = dot(ray_to_0, ray_cross_edge_1);
	barycentrics.y = rcp_det_edges_direction * det_0_dir_edge_1;
	vec3 edge_0_cross_0 = cross(edges[0], ray_to_0);
	float det_dir_edge_0_0 = dot(ray_direction, edge_0_cross_0);
	barycentrics.z = -rcp_det_edges_direction * det_dir_edge_0_0;
	barycentrics.x = 1.0f - (barycentrics.y + barycentrics.z);
	
	result.Position = fma(vec3(barycentrics[0]), positions[0], fma(vec3(barycentrics[1]), positions[1], barycentrics[2] * positions[2]));
	result.Normal = normalize(fma(vec3(barycentrics[0]), normals[0], fma(vec3(barycentrics[1]), normals[1], barycentrics[2] * normals[2])));
	result.TexCoord = fma(vec2(barycentrics[0]), tex_coords[0], fma(vec2(barycentrics[1]), tex_coords[1], barycentrics[2] * tex_coords[2]));
	result.MaterialIndex = matid;
	
	return result;
}

vec3 get_position(ivec2 pixel, uint primitive_index, vec3 ray_origin , vec3 ray_direction)
{
	vec3 positions[3];
	
	for (int i = 0; i != 3; ++i) {
		uint vertex_index = primitive_index * 3 + i;
		const Vertex v = UnpackVertex(vertex_index);
		positions[i] = v.Position;
	}

	vec3 barycentrics;
	vec3 edges[2] = {
	positions[1] - positions[0],
	positions[2] - positions[0]
	};

	vec3 ray_cross_edge_1 = cross(ray_direction, edges[1]);
	float rcp_det_edges_direction = 1.0f / dot(edges[0], ray_cross_edge_1);
	vec3 ray_to_0 = ray_origin - positions[0];
	float det_0_dir_edge_1 = dot(ray_to_0, ray_cross_edge_1);
	barycentrics.y = rcp_det_edges_direction * det_0_dir_edge_1;
	vec3 edge_0_cross_0 = cross(edges[0], ray_to_0);
	float det_dir_edge_0_0 = dot(ray_direction, edge_0_cross_0);
	barycentrics.z = -rcp_det_edges_direction * det_dir_edge_0_0;
	barycentrics.x = 1.0f - (barycentrics.y + barycentrics.z);

	return fma(vec3(barycentrics[0]), positions[0], fma(vec3(barycentrics[1]), positions[1], barycentrics[2] * positions[2]));
}

// The helper for the equirectangular textures.
vec4 equirectangularSample(vec3 direction, float rotate)
{
	const float pi = 3.1415926535897932384626433832795;
	vec3 d = normalize(direction);
	vec2 t = vec2((atan(d.x, d.z) + pi * rotate) / (2.f * pi), acos(d.y) / pi);

	return min( vec4(10,10,10,1), texture(TextureSamplers[0], t));
}

float Schlick(const float cosine, const float refractionIndex)
{
	float r0 = (1 - refractionIndex) / (1 + refractionIndex);
	r0 *= r0;
	return r0 + (1 - r0) * pow(1 - cosine, 5);
}

vec3 TraceRay(vec3 origin, vec3 direction)
{
    // screen space ray-marching
    // if we hit light material, light-it
	const vec4 campos = Camera.ModelViewInverse * vec4(0, 0, 0, 1);
	const ivec2 size = imageSize(MiniGBuffer);
	const float stepLength = 0.06;
	// brute force by step
	for(int i = 0; i < 6; ++i)
	{
		origin += direction * (stepLength * i);
		float rayDist = length(origin - campos.xyz);
		vec4 hpos =  Camera.ViewProjection * vec4(origin, 1);
		ivec2 ipos_new = ivec2((hpos.xy / hpos.w * 0.5 + 0.5) * size);
		if(ipos_new.x < 0 || ipos_new.y < 0 || ipos_new.x > size.x || ipos_new.y > size.y)
		{
			return vec3(1);
		}
		vec2 uv = vec2(ipos_new) / vec2(size) * 2.0 - 1.0;
		vec4 target = Camera.ProjectionInverse * (vec4(uv.x, uv.y, 1, 1));
		vec4 dir = Camera.ModelViewInverse * vec4(normalize(target.xyz), 0);
		uint primitive_index = imageLoad(MiniGBuffer, ipos_new).r;
		
		// fast hit
		vec3 hitpos = get_position(ipos_new, primitive_index, campos.xyz, dir.xyz);
		if(rayDist > length(hitpos - campos.xyz) + 0.2)
		{
			return vec3(0);
		}
		
		// hit with mat
		//Vertex v = get_material_data(ipos_new, primitive_index, campos.xyz, dir.xyz);
		//if(rayDist > length(v.Position - campos.xyz) + 0.2)
		{
		//    Material mat = Materials[v.MaterialIndex];
		//    if(mat.MaterialModel == MaterialDiffuseLight)
		    {
		//        return vec3(20);
		    }
		//    return vec3(0);
		}
	}
	
	// accleration by scene distance field
	
	// accleration by rayquery
	
	
	return vec3(1);
}

// hsv to rgb
vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

vec3 LinearToST2084UE(vec3 lin)
{
	const float m1 = 0.1593017578125; // = 2610. / 4096. * .25;
	const float m2 = 78.84375; // = 2523. / 4096. *  128;
	const float c1 = 0.8359375; // = 2392. / 4096. * 32 - 2413./4096.*32 + 1;
	const float c2 = 18.8515625; // = 2413. / 4096. * 32;
	const float c3 = 18.6875; // = 2392. / 4096. * 32;
	const float C = 10000.;

	vec3 L = lin/C;
	vec3 Lm = pow(L, vec3(m1));
	vec3 N1 = ( c1 + c2 * Lm );
	vec3 N2 = ( 1.0 + c3 * Lm );
	vec3 N = N1 * (1.0 / N2);
	vec3 P = pow( N, vec3(m2) );

	return P;
}

void main() {

    // checker box
    int adder = Camera.TotalFrames % 2 == 0 ? 1 : 0;
    
    ivec2 ipos = ivec2(gl_GlobalInvocationID.xy);
    if(Camera.UseCheckerBoard)
    {
        ipos = ipos * ivec2(2,1);
        if((gl_GlobalInvocationID.y + adder) % 2 == 0) {
            ipos.x += 1;
        }
    }

	
	ivec2 size = imageSize(MiniGBuffer);
    uvec2 vBuffer = imageLoad(MiniGBuffer, ipos).rg;
    vec2 uv = vec2(ipos) / vec2(size) * 2.0 - 1.0;
    vec4 origin = Camera.ModelViewInverse * vec4(0, 0, 0, 1);
	vec4 target = Camera.ProjectionInverse * (vec4(uv.x, uv.y, 1, 1));
	vec4 dir = Camera.ModelViewInverse * vec4(normalize(target.xyz), 0);
	
	vec3 ray_dir = normalize(dir.xyz);
    
    Vertex v = get_material_data(ipos, vBuffer, origin.xyz, ray_dir);
    
    Material mat = Materials[v.MaterialIndex];
    vec4 albedo = mat.Diffuse;
    if (mat.DiffuseTextureId >= 0)
    {
        vec4 tex = texture(TextureSamplers[mat.DiffuseTextureId], v.TexCoord);
        albedo *= tex * tex;
    }
	
	vec3 normal = normalize( v.Normal.rgb);
	// ibl
	const float dotValue = dot(ray_dir, normal);
	const vec3 outwardNormal = dotValue > 0 ? -normal : normal;
	const float cosine = dotValue > 0 ? mat.RefractionIndex * dotValue : -dotValue;
	const float reflectProb = Schlick(cosine, mat.RefractionIndex);
	const float metalProb = mat.Metalness;
	
	uint RandomSeed = InitRandomSeed(InitRandomSeed(ipos.x, ipos.y), Camera.TotalFrames);
	int numSamples = 2;
	vec3 skyColor = vec3(1);
	
	if(false)
	{
		for( int i = 0; i < numSamples; i++ )
		{
			vec3 trace_dir = RandomFloat(RandomSeed) < reflectProb ?
			AlignWithNormal( RandomInCone(RandomSeed, cos(mat.Fuzziness * 45.f / 180.f * 3.14159f)), reflect( ray_dir, outwardNormal) ) :
			( RandomFloat(RandomSeed) < metalProb ?
			AlignWithNormal( RandomInCone(RandomSeed, cos(mat.Fuzziness * 45.f / 180.f * 3.14159f)), reflect( ray_dir, outwardNormal) ) :
			AlignWithNormal( RandomInHemiSphere(RandomSeed), outwardNormal )
			);

			//vec3 trace_dir = AlignWithNormal( RandomInHemiSphere(RandomSeed), normalize( v.Normal.rgb) );

			// screen space ray query
			//if( !TraceRay(v.Position, trace_dir) )
			{
				// if miss, sample the sky	
				vec3 hitColor = TraceRay(v.Position, trace_dir);
				const float t = 0.5*(trace_dir.y + 1);
				//const float t = step(0, trace_dir.y);
				skyColor += equirectangularSample(trace_dir, Camera.SkyRotation).rgb * 8.0 * hitColor;
			}
		}
		skyColor = skyColor / float(numSamples);
	}
	
    //albedo = mix(albedo, vec4(1,1,1,1), reflectProb);

	const vec3 lightVector = normalize(vec3(5, 4, 3));
    const float d = max(dot(lightVector, normalize(v.Normal.rgb)) * 20.0, 0.5);
    
    vec4 outColor = albedo * d * vec4(skyColor,1);

	outColor.rgb = LinearToST2084UE(outColor.rgb * Camera.PaperWhiteNit / 230.0);

//  visibiliy visualizer	
//	uint triangle_index = primitive_index & 0x000FFFFF;
//	outColor.rgb = hsv2rgb(vec3(RandomFloat(triangle_index),0.2,0.5));
	
    imageStore(OutImage, ipos, outColor);
	
	
	// calculate the motion vector
	vec4 currFrameHPos = Camera.ViewProjection * vec4(v.Position, 1);
	vec2 currfpos = vec2((currFrameHPos.xy / currFrameHPos.w * 0.5 + 0.5) * vec2(size));
	
	vec4 prevFrameHPos = Camera.PrevViewProjection * vec4(v.Position, 1);
	vec2 prevfpos = vec2((prevFrameHPos.xy / prevFrameHPos.w * 0.5 + 0.5) * vec2(size));
	vec2 motion = prevfpos - currfpos;
	imageStore(OutMotionVector, ipos, vec4(motion,0,0));
}