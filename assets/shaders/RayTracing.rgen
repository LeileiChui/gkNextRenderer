#version 460
#extension GL_ARB_gpu_shader_int64 : require
#extension GL_ARB_shader_clock : require
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_ray_tracing : require

#include "Heatmap.glsl"
#include "Random.glsl"
#include "RayPayload.glsl"
#include "UniformBufferObject.glsl"

layout(binding = 0, set = 0) uniform accelerationStructureEXT Scene;
layout(binding = 1, rgba32f) uniform image2D AccumulationImage;
layout(binding = 2, rg16f) uniform image2D MotionVectorImage;
layout(binding = 3) readonly uniform UniformBufferObjectStruct { UniformBufferObject Camera; };
layout(binding = 10, rgba32f) uniform image2D GBufferImage;
layout(binding = 11, rgba16f) uniform image2D Output1Image;
layout(binding = 12, rgba16f) uniform image2D AlbedoImage;

layout(location = 0) rayPayloadEXT RayPayload Ray;


#define GetRayColorGen(name,name0) \
vec3 name(vec3 origin, vec3 scatterDir){ \
	traceRayEXT(Scene, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0,origin.xyz, 0.001, scatterDir, 10000.0, 0);\
	vec3 atten = Ray.Attenuation;\
	vec3 emit = Ray.EmitColor.rgb;\
	if(Ray.Distance < 0)\
	{\
		return emit;\
	}\
	origin = origin + scatterDir * Ray.Distance;\
	return emit + atten * Ray.pdf * name0(origin, Ray.ScatterDirection);\
}

vec3 GetRayColorEnd(vec3 origin, vec3 scatterDir)
{
	return vec3(0);
}

GetRayColorGen(GetRayColor7,GetRayColorEnd)
GetRayColorGen(GetRayColor6,GetRayColor7)
GetRayColorGen(GetRayColor5,GetRayColor6)
GetRayColorGen(GetRayColor4,GetRayColor5)
GetRayColorGen(GetRayColor3,GetRayColor4)
GetRayColorGen(GetRayColor2,GetRayColor3)
GetRayColorGen(GetRayColor1,GetRayColor2)

vec3 GetPrimaryRayColor(vec3 origin, vec3 scatterDir, out vec4 gbuffer, out vec4 albedo, out vec4 motionVector)
{
	// trace ray
	traceRayEXT(Scene, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, 
		origin.xyz, 0.001, scatterDir, 10000.0, 0);

	origin = origin + scatterDir * Ray.Distance;
	
	
	//vec3 atten = vec3(1.0);//Ray.ColorAndDistance.rgb; albedo later compose
	vec3 atten = Ray.Attenuation;
	vec3 emit = Ray.EmitColor.rgb;

	// fetch albedo
	gbuffer = vec4(Ray.GBuffer.xyz, Ray.Distance);
	albedo = vec4(Ray.Attenuation, Ray.GBuffer.w);
		
	vec2 size = imageSize(MotionVectorImage);
	vec4 currFrameHPos = Camera.ViewProjection * vec4(origin, 1);
	vec2 currfpos = vec2((currFrameHPos.xy / currFrameHPos.w * 0.5 + 0.5) * vec2(size));
	vec4 prevFrameHPos = Camera.PrevViewProjection * vec4(origin, 1);
	vec2 prevfpos = vec2((prevFrameHPos.xy / prevFrameHPos.w * 0.5 + 0.5) * vec2(size));
	motionVector = vec4(prevfpos - currfpos,0,0);
	
	if(Ray.Distance < 0)
	{
		return emit;
	}
	
	return emit + atten * Ray.pdf * GetRayColor1(origin, Ray.ScatterDirection);
}

void main() 
{
	// use checkerbord to skip sample
	int adder = Camera.TotalFrames % 2 == 0 ? 1 : 0;
	
	ivec2 ipos = ivec2(gl_LaunchIDEXT.xy);
	vec2 isize = vec2(gl_LaunchSizeEXT.xy);

	if(Camera.UseCheckerBoard)
	{
		ipos = ipos * ivec2(2,1);
		isize = isize * vec2(2,1);
		if((gl_LaunchIDEXT.y + adder) % 2 == 0) 
		{
			ipos.x += 1;
		}
	}
    
	const uint64_t clock = Camera.ShowHeatmap ? clockARB() : 0;

	// Initialise separate random seeds for the pixel and the rays.
	// - pixel: we want the same random seed for each pixel to get a homogeneous anti-aliasing.
	// - ray: we want a noisy random seed, different for each pixel.
	uint pixelRandomSeed = Camera.RandomSeed;
    vec2 uvOffset = vec2(RandomFloat(pixelRandomSeed), RandomFloat(pixelRandomSeed)) / isize;
	Ray.RandomSeed = InitRandomSeed(InitRandomSeed(ipos.x, ipos.y), Camera.TotalFrames);
    
    const vec3 exitColor = vec3(0.0);
	vec3 pixelColor = vec3(0);
			
	vec4 gbuffer = vec4(0);
	vec4 albedo = vec4(0);
	vec4 motionvector = vec4(0);
	
	// Accumulate all the rays for this pixels.
	for (uint s = 0; s < Camera.NumberOfSamples; ++s)
	{
		const vec2 pixel = vec2(ipos);
		vec2 uv = (pixel / isize) * 2.0 - 1.0;
		// anti aliasing
        uv += uvOffset;
       
		vec2 offset = Camera.Aperture / 2 * RandomInUnitDisk(Ray.RandomSeed);
		vec4 origin = Camera.ModelViewInverse * vec4(offset, 0, 1);
		vec4 target = Camera.ProjectionInverse * (vec4(uv.x, uv.y, 1, 1));
        // physical camera
		vec4 direction = Camera.ModelViewInverse * vec4(normalize(target.xyz * Camera.FocusDistance * 0.01 - vec3(offset, 0)), 0);
		// accumulate the raycolor

		vec4 s_albedo = vec4(0);
		vec3 rayColor = GetPrimaryRayColor(origin.xyz, direction.xyz, gbuffer, s_albedo, motionvector);
		albedo += s_albedo;
		// if s == 0, store
		if( s == 0 )
		{
			imageStore(GBufferImage, ipos, gbuffer);
			imageStore(MotionVectorImage, ipos, motionvector);
		}
			
		pixelColor += rayColor;
	}
    
    pixelColor = pixelColor / Camera.NumberOfSamples;

	imageStore(AlbedoImage, ipos, albedo / Camera.NumberOfSamples);
		
	if (Camera.ShowHeatmap)
	{
		const uint64_t deltaTime = clockARB() - clock;
		const float heatmapScale = 1000000.0f * Camera.HeatmapScale * Camera.HeatmapScale;
		const float deltaTimeScaled = clamp(float(deltaTime) / heatmapScale, 0.0f, 1.0f);
		pixelColor = heatmap(deltaTimeScaled);
	}

	// output to accumulation directly
	imageStore(AccumulationImage, ipos, vec4(pixelColor, 0));
}
