#version 460
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_GOOGLE_include_directive : require
//#extension GL_EXT_ray_tracing : require
#extension GL_EXT_ray_query : require

#define RQ_PIPELINE

#include "Platform.glsl"
#include "common/Material.glsl"
#include "common/UniformBufferObject.glsl"

layout(binding = 0, set = 0) uniform accelerationStructureEXT Scene;
layout(binding = 1) readonly buffer LightObjectArray { LightObject[] Lights; };
layout(binding = 3) readonly uniform UniformBufferObjectStruct { UniformBufferObject Camera; };
layout(binding = 4) readonly buffer VertexArray { float Vertices[]; };
layout(binding = 5) readonly buffer IndexArray { uint Indices[]; };
layout(binding = 6) readonly buffer MaterialArray { Material[] Materials; };
layout(binding = 7) readonly buffer OffsetArray { uvec2[] Offsets; };
layout(binding = 8) uniform sampler2D[] TextureSamplers;
layout(binding = 9, rgba8) uniform image2D OutImage;

#include "common/Const_Func.glsl"
#include "common/ColorFunc.glsl"

#include "common/RayPayload.glsl"
RayPayload Ray;
#include "common/RTCommon.glsl"

#if DESKTOP
layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;
#else
layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;
#endif

void main() {
    
    vec3 pixelColor = vec3(0);
	vec4 gbuffer = vec4(0);
	vec4 motionvector = vec4(0);
    
    ivec2 ipos = ivec2(gl_GlobalInvocationID.xy);
    vec2 isize = vec2(imageSize(OutImage));
    
    // Ray Initialize
    Ray.RandomSeed = InitRandomSeed(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y, Camera.TotalFrames);
	Ray.RandomSeed.w = Camera.RandomSeed;
    
    
    for (uint s = 0; s < Camera.NumberOfSamples; ++s)
	{
        const vec2 pixel = vec2(ipos);
        vec2 uv = (pixel / isize) * 2.0 - 1.0;
        vec2 offset = vec2(0);
        vec4 origin = Camera.ModelViewInverse * vec4(offset, 0, 1);
        vec4 target = Camera.ProjectionInverse * (vec4(uv.x, uv.y, 1, 1));
        // physical camera
        vec4 direction = Camera.ModelViewInverse * vec4(normalize(target.xyz * Camera.FocusDistance * 0.01 - vec3(offset, 0)), 0);
		
        // Path Tracing
		vec4 s_albedo = vec4(0);
		uint primitiveId = 0;
        vec3 rayColor = vec3(1);

	    Ray.BounceCount = 0;
        bool exit = GetRayColor(origin.xyz, direction.xyz, rayColor);
        FetchPrimaryRayInfo(isize, origin.xyz, direction.xyz, gbuffer, s_albedo, motionvector, primitiveId);
        if(!exit)
        {
            for(uint b = 0; b < Camera.NumberOfBounces; ++b)
            {	
                if( GetRayColor(origin.xyz, direction.xyz, rayColor) )
                {
                    break;
                }
            }
        }
        
        pixelColor += rayColor;
    }
    
    pixelColor = pixelColor / Camera.NumberOfSamples;
    
    // Quick Result
    imageStore(OutImage, ipos, vec4( LinearToST2084UE( pixelColor * 600.0 / 230.0), 1.0) );
}