#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_nonuniform_qualifier : require

#include "Platform.glsl"
#include "Material.glsl"
#include "UniformBufferObject.glsl"

layout(binding = 0, rgba8) readonly uniform image2D GBuffer0Image;
layout(binding = 1, rgba16f) readonly uniform image2D GBuffer1Image;
layout(binding = 2, rgba8) readonly uniform image2D GBuffer2Image;
layout(binding = 3, rgba8) writeonly uniform image2D OutImage;
layout(binding = 4) readonly uniform UniformBufferObjectStruct { UniformBufferObject Camera; };

vec3 LinearToST2084UE(vec3 lin)
{
    const float m1 = 0.1593017578125; // = 2610. / 4096. * .25;
    const float m2 = 78.84375; // = 2523. / 4096. *  128;
    const float c1 = 0.8359375; // = 2392. / 4096. * 32 - 2413./4096.*32 + 1;
    const float c2 = 18.8515625; // = 2413. / 4096. * 32;
    const float c3 = 18.6875; // = 2392. / 4096. * 32;
    const float C = 10000.;

    vec3 L = lin/C;
    vec3 Lm = pow(L, vec3(m1));
    vec3 N1 = ( c1 + c2 * Lm );
    vec3 N2 = ( 1.0 + c3 * Lm );
    vec3 N = N1 * (1.0 / N2);
    vec3 P = pow( N, vec3(m2) );

    return P;
}

//layout(push_constant) uniform PushConsts {
//    uint pingpong;
//    uint stepsize;
//} pushConsts;

#if DESKTOP
layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;
#else
layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;
#endif

void main() {

    // checker box
    int adder = Camera.TotalFrames % 2 == 0 ? 1 : 0;
    
    ivec2 ipos = ivec2(gl_GlobalInvocationID.xy);
    if(Camera.UseCheckerBoard)
    {
        ipos = ipos * ivec2(2,1);
        if((gl_GlobalInvocationID.y + adder) % 2 == 0) {
            ipos.x += 1;
        }
    }
	
    vec4 albedo = imageLoad(GBuffer0Image, ipos);
    vec4 normalraw = imageLoad(GBuffer1Image, ipos);
    vec4 pbr_param = imageLoad(GBuffer2Image, ipos);
    
    vec3 normal = normalize(normalraw.rgb);

    const float t = 0.5*(normal.y + 1);
    vec4 skyColor = vec4( mix(vec3(1.0), vec3(0.5, 0.7, 1.0) * 20, t), 1.0);
    
    const vec3 lightVector = normalize(vec3(5, 4, 3));
    const float d = max(dot(lightVector, normal) * 20.0, 0.5);

    vec4 outColor = albedo * d + (pbr_param.r * 0.000001) + skyColor * albedo;
    outColor.rgb = LinearToST2084UE(outColor.rgb * Camera.PaperWhiteNit / 230.0);
    
    imageStore(OutImage, ipos, outColor);
}