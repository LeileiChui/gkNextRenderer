#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_ray_query : require
#include "Platform.glsl"
#include "common/Const_Func.glsl"
#include "common/Material.glsl"
#include "common/UniformBufferObject.glsl"

// placed me in a 200 x 200 x 100 grid, total 4,000,000 cubes, total size 4,000,000 * 6 * 4 * 4 = 384 MB
// it the gap is 10 cm, it will cover 20 x 20 x 10 meters area

// for basic testing demo, we use 50 x 50 x 50 to represent 5 x 5 x 5 meters area, the default cornell box is 5 x 5 x 5 meters
// it may simple gen every frame

// we use 128 ray per cube, it can accumulate with last 16 frames

// every cube face, tracing a hemisphere uniformly

// the basic algorithm
// 1. get the area center
// 2. get the tracing origin
// 3. tracing the ray, only get the visibiliy for the first iteration
// 4. record to storage buffer

// when shading
// 1. sample the ambient cube with world pos, lerp in 3d, get the color as indirect light
// 2. tracing direct reflection

// when area center moving
// 1. move still in bound cubes, then update new cubes

layout(binding = 0, set = 0) uniform accelerationStructureEXT Scene;
layout(binding = 1) buffer AmbientCubeArray { AmbientCube[] Cubes; };
//layout(binding = 3) readonly uniform UniformBufferObjectStruct { UniformBufferObject Camera; };
layout(binding = 4) readonly buffer VertexArray { float Vertices[]; };
layout(binding = 5) readonly buffer IndexArray { uint Indices[]; };
layout(binding = 6) readonly buffer MaterialArray { Material[] Materials; };
layout(binding = 7) readonly buffer OffsetArray { uvec2[] Offsets; };
layout(binding = 8) readonly buffer NodeProxyArray { NodeProxy[] NodeProxies; };

layout(set = 1, binding = 0) uniform sampler2D TextureSamplers[];

#include "common/RTSimple.glsl"

layout(local_size_x = 50, local_size_y = 1, local_size_z = 1) in;

const uint CUBE_SIZE = 50;

void main() {
    
    uint gIdx = gl_GlobalInvocationID.x;
    
    // convert to local position
    uint z = gIdx / (CUBE_SIZE * CUBE_SIZE);
    uint y = (gIdx - z * CUBE_SIZE * CUBE_SIZE) / CUBE_SIZE;
    uint x = gIdx - z * CUBE_SIZE * CUBE_SIZE - y * CUBE_SIZE;
    
    vec3 origin = vec3(x, y, z) * 0.1 + vec3(0.0, 5.0, 0.0);

    rayQueryEXT rayQuery;
    rayQueryInitializeEXT(rayQuery, Scene, gl_RayFlagsNoneEXT, 0xFF, origin.xyz, EPS, vec3(0,1,0), INF);

    while( rayQueryProceedEXT(rayQuery) )
    {

    }

    if (rayQueryGetIntersectionTypeEXT(rayQuery, true) == gl_RayQueryCommittedIntersectionTriangleEXT  ) {
//        const bool IsCommitted = true;
//        const int InstCustIndex = rayQueryGetIntersectionInstanceCustomIndexEXT(rayQuery, IsCommitted);
//        const vec3 RayOrigin = context.Origin.xyz;
//        const vec3 RayDirection = context.Direction.xyz;
//        const float RayDist = rayQueryGetIntersectionTEXT(rayQuery, IsCommitted);
//        const mat4x3 WorldToObject = rayQueryGetIntersectionWorldToObjectEXT(rayQuery, IsCommitted);
//        const vec2 TwoBaryCoords = rayQueryGetIntersectionBarycentricsEXT(rayQuery, IsCommitted);
//        const vec3 HitPos = RayOrigin + RayDirection * RayDist;
//        const int PrimitiveIndex = rayQueryGetIntersectionPrimitiveIndexEXT(rayQuery, IsCommitted);
//        const int InstanceID = rayQueryGetIntersectionInstanceIdEXT(rayQuery, IsCommitted);
//
//        vec3 OutNormal;
//        vec2 OutTexcoord;
//        uint OutMaterialId;
//        uint OutInstanceId;
//        SimpleHit(InstCustIndex, WorldToObject, TwoBaryCoords, PrimitiveIndex, InstanceID, OutNormal, OutTexcoord, OutMaterialId, OutInstanceId);
//
//        context.HitPoint = vec4(HitPos, 1.0);
//        context.Normal = vec4(OutNormal, 0.0);
//        context.Hitted = 1;
//        context.T = RayDist;
//        context.InstanceId = OutInstanceId;
//        context.MaterialId = OutMaterialId;
        Cubes[gl_GlobalInvocationID.x].PosY = vec4(0,0,0,0);
    }
    else
    {
        //context.Hitted = 0;
        Cubes[gl_GlobalInvocationID.x].PosY = vec4(0,0,0,1);
    }
}
