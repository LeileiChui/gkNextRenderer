#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_ray_query : require
#extension GL_EXT_nonuniform_qualifier : require
#include "Platform.glsl"
#include "common/Const_Func.glsl"
#include "common/Material.glsl"
#include "common/UniformBufferObject.h"
#include "common/Random.glsl"

layout(binding = 0, set = 0) uniform accelerationStructureEXT Scene;
layout(binding = 1) buffer AmbientCubeArray { AmbientCube[] Cubes; };
layout(binding = 2) readonly buffer LightObjectArray { LightObject[] Lights; };
layout(binding = 3) readonly uniform UniformBufferObjectStruct { UniformBufferObject Camera; };
layout(binding = 4) readonly buffer VertexArray { float Vertices[]; };
layout(binding = 5) readonly buffer IndexArray { uint Indices[]; };
layout(binding = 6) readonly buffer MaterialArray { Material[] Materials; };
layout(binding = 7) readonly buffer OffsetArray { uvec2[] Offsets; };
layout(binding = 8) readonly buffer NodeProxyArray { NodeProxy[] NodeProxies; };
layout(binding = 9) readonly buffer HDRSHArray { SphericalHarmonics[] HDRSHs; };

layout(set = 1, binding = 0) uniform sampler2D TextureSamplers[];

layout(push_constant) uniform PushConsts {
    uint globalOffset;
    uint unitSize;
} pushConsts;

#include "common/RTSimple.glsl"
#include "common/AmbientCube.glsl"
#include "common/SampleIBL.h"

#if DESKTOP
layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;
#else
layout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;
#endif


#define HIGH_QUALITY 0

const vec3 hemisphereVectors32[32] = {
vec3(0.06380871270368209, -0.16411674977923174, 0.984375),
vec3(-0.2713456981395, 0.13388146427413833, 0.953125),
vec3(0.3720439325965911, 0.1083041854826636, 0.921875),
vec3(-0.2360905314110366, -0.38864941831045413, 0.890625),
vec3(-0.0994527932145428, 0.5015812509422829, 0.859375),
vec3(0.4518001015172772, -0.3317915801282155, 0.828125),
vec3(-0.6006110862696151, -0.06524229782152816, 0.796875),
vec3(0.4246400102205648, 0.4832175711777031, 0.765625),
vec3(0.014025106917771066, -0.6785990390141627, 0.734375),
vec3(-0.4910499646725058, 0.5142812135107899, 0.703125),
vec3(0.7390090634100329, -0.04949331846649647, 0.671875),
vec3(-0.5995855814426192, -0.47968400004702705, 0.640625),
vec3(0.12194313936463708, 0.7834487731414841, 0.609375),
vec3(0.4520746755881747, -0.6792642873483389, 0.578125),
vec3(-0.8128288753565273, 0.2005915096948101, 0.546875),
vec3(0.7520560261769773, 0.41053939258723227, 0.515625),
vec3(-0.28306625928882, -0.8278009134008216, 0.48437499999999994),
vec3(-0.357091373373129, 0.8168007623879232, 0.4531249999999999),
vec3(0.8289528112710368, -0.36723115480694823, 0.42187500000000006),
vec3(-0.8724752793478753, -0.29359665580835004, 0.39062500000000006),
vec3(0.45112649883473616, 0.8169054360353547, 0.35937499999999994),
vec3(0.22185204734195418, -0.9182132941017481, 0.328125),
vec3(-0.792362708282336, 0.5329414347735422, 0.296875),
vec3(0.9533182286148584, 0.1436235160606669, 0.26562499999999994),
vec3(-0.6110028678351297, -0.756137457657169, 0.23437499999999994),
vec3(-0.06066310322190489, 0.9772718261990818, 0.20312499999999992),
vec3(0.7091634641369421, -0.683773475288631, 0.17187500000000008),
vec3(-0.9897399665274648, 0.025286518803760413, 0.14062500000000008),
vec3(0.749854715318357, 0.6524990538612495, 0.1093750000000001),
vec3(-0.11249484107422018, -0.9905762944401031, 0.0781250000000001),
vec3(-0.587325250956154, 0.8079924405365998, 0.046875),
vec3(0.9798239737002217, -0.19925069620281746, 0.01562500000000002)
};
const vec3 hemisphereVectors16[16] = {
vec3(0.0898831725494359, -0.23118056318048955, 0.96875),
vec3(-0.3791079112581037, 0.18705114039085075, 0.90625),
vec3(0.5153445316614019, 0.15001983597741456, 0.84375),
vec3(-0.3240808043433482, -0.5334979566560387, 0.78125),
vec3(-0.1352243320429325, 0.6819918016542008, 0.71875),
vec3(0.6081648613009205, -0.4466222553554984, 0.65625),
vec3(-0.7999438572571327, -0.08689512492988453, 0.59375),
vec3(0.559254806831153, 0.6364019944471022, 0.53125),
vec3(0.018252552906059358, -0.8831422772194816, 0.46875000000000006),
vec3(-0.6310280835640938, 0.66088160456577, 0.40624999999999994),
vec3(0.9369622623684265, -0.06275074818231247, 0.34374999999999994),
vec3(-0.7493392047328667, -0.5994907787033216, 0.2812499999999999),
vec3(0.1500724796134238, 0.9641715036043528, 0.21875),
vec3(0.5472431702110503, -0.8222596002220706, 0.15624999999999997),
vec3(-0.9665972247046685, 0.2385387655984508, 0.09375000000000008),
vec3(0.8773063928879596, 0.47891223673854594, 0.03125000000000001)
};

#if HIGH_QUALITY
const uint FACE_TRACING = 32;
#else
const uint FACE_TRACING = 16;
#endif


// return if hits, this function may differ between Shader & Cpp
bool TracingFunction(in vec3 origin, in vec3 rayDir, out vec3 OutNormal, out uint OutMaterialId, out float OutRayDist)
{
    rayQueryEXT rayQuery;
    rayQueryInitializeEXT(rayQuery, Scene, gl_RayFlagsNoneEXT, 0xFF, origin.xyz, EPS, rayDir, 10.0f);

    while( rayQueryProceedEXT(rayQuery) )
    {

    }

    if (rayQueryGetIntersectionTypeEXT(rayQuery, true) == gl_RayQueryCommittedIntersectionTriangleEXT  ) {
        const bool IsCommitted = true;
        const int InstCustIndex = rayQueryGetIntersectionInstanceCustomIndexEXT(rayQuery, IsCommitted);
        const float RayDist = rayQueryGetIntersectionTEXT(rayQuery, IsCommitted);
        const mat4x3 WorldToObject = rayQueryGetIntersectionWorldToObjectEXT(rayQuery, IsCommitted);
        const vec2 TwoBaryCoords = rayQueryGetIntersectionBarycentricsEXT(rayQuery, IsCommitted);
        const int PrimitiveIndex = rayQueryGetIntersectionPrimitiveIndexEXT(rayQuery, IsCommitted);
        const int InstanceID = rayQueryGetIntersectionInstanceIdEXT(rayQuery, IsCommitted);
        OutRayDist = RayDist;

        vec2 OutTexcoord;
        uint OutInstanceId;
        SimpleHit(InstCustIndex, WorldToObject, TwoBaryCoords, PrimitiveIndex, InstanceID, OutNormal, OutTexcoord, OutMaterialId, OutInstanceId);
        return true;
    }

    return false;
}

int TracingOccludeFunction(in vec3 origin, in vec3 lightPos)
{
    float dist = length(lightPos - origin);
    vec3 lightDir = (lightPos - origin) / dist;
    
    rayQueryEXT rayQuery;
    rayQueryInitializeEXT(rayQuery, Scene, gl_RayFlagsTerminateOnFirstHitEXT, 0xFF, origin, EPS, lightDir, dist - EPS2);

    rayQueryProceedEXT(rayQuery);

    if (rayQueryGetIntersectionTypeEXT(rayQuery, true) == gl_RayQueryCommittedIntersectionTriangleEXT) {
        return 0;
    }
    else
    {
        return 1;
    }
}

int TraceShadow(vec3 origin, vec3 lightPos)
{
    if( !Camera.HasSun )
    {
        return 0;
    }
    return TracingOccludeFunction(origin, lightPos);
}

vec4 TraceOcclusion(inout uvec4 RandomSeed, vec3 origin, vec3 basis, inout int activeProbe)
{
    float occlusion = 0.0;
    float hitDist = 0.0;
    float hitCount = 0.000001;
    vec3 rayColor = vec3(0.0);

    // Generate a random angle for z-axis rotation
    float randAngle = RandomFloat(RandomSeed) * M_TWO_PI;
    float cosTheta = cos(randAngle);
    float sinTheta = sin(randAngle);
    
    for( uint i = 0; i < FACE_TRACING; i++ )
    {
        #if HIGH_QUALITY
        vec3 hemiVec = hemisphereVectors32[i];
        #else
        vec3 hemiVec = hemisphereVectors16[i];
        #endif

        // Apply rotation around z-axis
        vec3 rotatedVec = vec3(
        hemiVec.x * cosTheta - hemiVec.y * sinTheta,
        hemiVec.x * sinTheta + hemiVec.y * cosTheta,
        hemiVec.z
        );

        // Align with the surface normal
        vec3 rayDir = AlignWithNormal(rotatedVec, basis);
        
        vec3 OutNormal;
        uint OutMaterialId;
        float OutRayDist;
        if( TracingFunction(origin, rayDir, OutNormal, OutMaterialId, OutRayDist) )
        {
            // if hit backface
            if( dot(OutNormal, rayDir) < 0.0 )
            {
                vec3 hitPos = origin + rayDir * OutRayDist;
                const Material material = Materials[OutMaterialId];
                occlusion += 1.0;
                hitDist += OutRayDist;
                hitCount += 1;

                ivec3 cubePos = ivec3(floor(hitPos));
                AmbientCube cube = FetchCube(cubePos);
                vec4 indirectLight = unpackUnorm4x8(cube.Info.y);

                // here it works, but the intensity should from the real sky and sun and lights, need improvement
                vec3 lightColor = vec3(0.5,0.5,0.5) * indirectLight.x + vec3(3.0,3.0,3.0) * indirectLight.y + vec3(1.0,1.0,1.0) * indirectLight.z;
                rayColor += clamp(material.Diffuse.rgb, 0, 1) * lightColor;
            }
            else
            {
                hitDist = 0.0;
                hitCount = 1;
                activeProbe = 0;
                break;
            }
        }
        else
        {
            hitDist += 1000.0;
            hitCount += 1;
            occlusion += 0.0;
            rayColor += SampleIBL(Camera.SkyIdx, rayDir, Camera.SkyRotation, 1.0).rgb;
        }
    }
    rayColor = rayColor / float(FACE_TRACING);
    
    if(Camera.LightCount > 0)
    {
        vec3 lightPos = mix(Lights[0].p1.rgb, Lights[0].p3.rgb, 0.5f);

        //AmbientCube cube = FetchCube(cubePos);
        float lightAtten = TracingOccludeFunction(origin, lightPos);

        vec3 lightDir = normalize(lightPos - origin);
        float ndotl = clamp(dot(basis, lightDir), 0.0f, 1.0f);
        float distance = length(lightPos - origin);
        float attenuation = 40.0f / (distance * distance);
        rayColor += vec3(0.6f, 0.6f, 0.6f) * ndotl * attenuation * lightAtten;
    }
    
    float avgDist = hitDist / hitCount;
    vec4 indirectColor = vec4(rayColor, avgDist);
    return indirectColor;
}

void main() {
    uint gIdx = gl_GlobalInvocationID.x + pushConsts.globalOffset;
    
    // convert to local position
    uint y = gIdx / (CUBE_SIZE_XY * CUBE_SIZE_XY);
    uint z = (gIdx - y * CUBE_SIZE_XY * CUBE_SIZE_XY) / CUBE_SIZE_XY;
    uint x = gIdx - y * CUBE_SIZE_XY * CUBE_SIZE_XY - z * CUBE_SIZE_XY;

    uvec4 RandomSeed = InitRandomSeed(x + y, y + z, Camera.TotalFrames);
    vec3 origin = vec3(x, y, z) * CUBE_UNIT + CUBE_OFFSET;
    
    int activeProbe = 1;
    Cubes[gIdx].PosY = LerpPackedColorAlt(Cubes[gIdx].PosY, TraceOcclusion(RandomSeed, origin, vec3(0,1,0), activeProbe),  0.125);
    Cubes[gIdx].NegY = LerpPackedColorAlt(Cubes[gIdx].NegY, TraceOcclusion(RandomSeed, origin, vec3(0,-1,0), activeProbe), 0.125);
    Cubes[gIdx].PosX = LerpPackedColorAlt(Cubes[gIdx].PosX, TraceOcclusion(RandomSeed, origin, vec3(1,0,0), activeProbe),  0.125);
    Cubes[gIdx].NegX = LerpPackedColorAlt(Cubes[gIdx].NegX, TraceOcclusion(RandomSeed, origin, vec3(-1,0,0), activeProbe), 0.125);
    Cubes[gIdx].PosZ = LerpPackedColorAlt(Cubes[gIdx].PosZ, TraceOcclusion(RandomSeed, origin, vec3(0,0,1), activeProbe),  0.125);
    Cubes[gIdx].NegZ = LerpPackedColorAlt(Cubes[gIdx].NegZ, TraceOcclusion(RandomSeed, origin, vec3(0,0,-1), activeProbe), 0.125);
    
    Cubes[gIdx].Info.x = activeProbe;
}
