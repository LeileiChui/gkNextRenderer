#version 460
#extension GL_GOOGLE_include_directive : require
#define WORKGROUP_SIZE 8

#include "UniformBufferObject.glsl"

layout(binding = 0, rgba16f) uniform image2D PingImage;
layout(binding = 1, rgba16f) uniform image2D PongImage;
layout(binding = 2, rgba32f) uniform image2D GBufferImage; // xyz normal, w depth
layout(binding = 3, rgba16f) uniform image2D AlbedoImage;
layout(binding = 4) readonly uniform UniformBufferObjectStruct { UniformBufferObject Camera; };

layout(push_constant) uniform PushConsts {
    uint pingpong;
    uint stepsize;
} pushConsts;

#define PINGPONG_IMAGE_IN(P) (pushConsts.pingpong == 1 ? imageLoad(PingImage, P) : imageLoad(PongImage, P))
#define PINGPONG_IMAGE_OUT(P) (pushConsts.pingpong == 1 ? imageLoad(PongImage, P) : imageLoad(PingImage, P))

layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;

float luminance(vec3 rgb)
{
    return max(dot(rgb, vec3(0.299, 0.587, 0.114)), 0.0001);
}

// atrous edge detect
float normalEdgeStoppingWeight(vec3 centerNormal, vec3 sampleNormal, float power)
{
    return pow(clamp(dot(centerNormal, sampleNormal), 0.0f, 1.0f), power);
}

float depthEdgeStoppingWeight(float centerDepth, float sampleDepth, float phi)
{
    return exp(-abs(centerDepth - sampleDepth) / phi);
}

float lumaEdgeStoppingWeight(float centerLuma, float sampleLuma, float phi)
{
    return abs(centerLuma - sampleLuma) / phi;
}

float computeEdgeStoppingWeight(
                      float centerDepth,
                      float sampleDepth,
                      float phiZ,
                      vec3  centerNormal,
                      vec3  sampleNormal,
                      float phiNormal,
                      float centerLuma,
                      float sampleLuma,
                      float phiLuma)
{
    const float wZ      = depthEdgeStoppingWeight(centerDepth, sampleDepth, phiZ);
    const float wNormal = normalEdgeStoppingWeight(centerNormal, sampleNormal, phiNormal);
    const float wL      = lumaEdgeStoppingWeight(centerLuma, sampleLuma, phiLuma);
    const float w       = exp(0.0 - max(wL, 0.0) - max(wZ, 0.0)) * wNormal;
    return w;
}

float computeVarianceCenter(ivec2 ipos)
{
    float sum = 0.0f;

    const float kernel[2][2] = {
        { 1.0 / 4.0, 1.0 / 8.0 },
        { 1.0 / 8.0, 1.0 / 16.0 }
    };

    const int radius = 1;
    for (int yy = -radius; yy <= radius; yy++)
    {
        for (int xx = -radius; xx <= radius; xx++)
        {
            ivec2 p = ipos + ivec2(xx, yy);
            float k = kernel[abs(xx)][abs(yy)];
            sum += PINGPONG_IMAGE_OUT(p).a * k;
        }
    }
    return sum;
}

void main() {
    // ping pong logic, select input & output bettwen Image0 & 1
    //int pingpong = gl_NumWorkGroups.x % 2 == 0 ? 1 : 0;
    int pingpong = int(pushConsts.pingpong);
    ivec2 ipos = ivec2(gl_GlobalInvocationID.xy);
    


    // get imagesize of gbuffer
    ivec2 size = imageSize(GBufferImage);
    vec4 gbuffer = imageLoad(GBufferImage, ipos);
    vec3 normal = gbuffer.xyz;
    float centerDepth = gbuffer.w;

    const float epsVariance      = 1e-10;
    const float kernelWeights[3] = { 1.0, 2.0 / 3.0, 1.0 / 6.0 };

	const float   phiColorT   = Camera.ColorPhi * 0.1;
	const float   phiNormalT  = Camera.NormalPhi;
    const int radiusT = 1;
    const int   stepSizeT  = int(pushConsts.stepsize);
    const float sigmaDepthT = Camera.DepthPhi;

    const vec4 srgbCenterColor = PINGPONG_IMAGE_OUT(ipos);
    const vec4 centerColor = srgbCenterColor;
    const float centerLuma = luminance(centerColor.rgb);
    //const float var = computeVarianceCenter(ipos);

    const float phiColor = phiColorT + epsVariance;//phiColorT * sqrt(max(0.0, var.r)) + epsVariance;

    float sumWeightColor = 1.0;
    vec4  sumColor = centerColor;

    // atrous core
    for (int yy = -radiusT; yy <= radiusT; yy++)
    {
        for (int xx = -radiusT; xx <= radiusT; xx++)
        {
            const ivec2 p = ipos + ivec2(xx, yy) * stepSizeT;
            const bool  inside = all(greaterThanEqual(p, ivec2(0, 0))) && all(lessThan(p, size));
            const float kernel = kernelWeights[abs(xx)] * kernelWeights[abs(yy)];

            if (inside && (xx != 0 || yy != 0))
            {
                const vec4 srgbSampleColor = PINGPONG_IMAGE_IN(p);
                const vec4 sampleColor = srgbSampleColor;
                const float sampleLuma = luminance(sampleColor.rgb);

                vec4 sampleNormal = imageLoad(GBufferImage, p);
                float depth = sampleNormal.a;

                // compute the edge-stopping functions
                const float w = computeEdgeStoppingWeight(centerDepth,
                                                             depth,
                                                             sigmaDepthT,
                                                             normal.xyz,
                                                             sampleNormal.xyz,
                                                             phiNormalT,
                                                             centerLuma,
                                                             sampleLuma,
                                                             phiColor);

                const float wVisibility = w * kernel;

                sumWeightColor += wVisibility;
                sumColor += vec4(vec3(wVisibility), wVisibility * wVisibility) * sampleColor;
            }
        }
    }

    sumColor = sumColor / vec4(vec3(sumWeightColor), sumWeightColor *sumWeightColor);
    vec4 outColor = sumColor;// / Camera.TotalNumberOfSamples;
        
    if(pingpong == 1)
    {
        imageStore(PongImage, ipos, outColor ); 
    }
    else
    {
        imageStore(PingImage, ipos, outColor );   
    }
}