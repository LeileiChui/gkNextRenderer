#version 460
#extension GL_GOOGLE_include_directive : require
#define WORKGROUP_SIZE 8

#include "UniformBufferObject.glsl"

layout(binding = 0, rgba32f) uniform image2D AccumulationImage;
layout(binding = 1, rgba8) uniform image2D OutputImage;
layout(binding = 2, rgba8) uniform image2D GBufferImage; // xyz normal, w depth
layout(binding = 3) readonly uniform UniformBufferObjectStruct { UniformBufferObject Camera; };

layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;

float luminance(vec3 rgb)
{
    return max(dot(rgb, vec3(0.299, 0.587, 0.114)), 0.0001);
}

// atrous edge detect
float normalEdgeStoppingWeight(vec3 centerNormal, vec3 sampleNormal, float power)
{
    return pow(clamp(dot(centerNormal, sampleNormal), 0.0f, 1.0f), power);
}

float depthEdgeStoppingWeight(float centerDepth, float sampleDepth, float phi)
{
    return exp(-abs(centerDepth - sampleDepth) / phi);
}

float lumaEdgeStoppingWeight(float centerLuma, float sampleLuma, float phi)
{
    return abs(centerLuma - sampleLuma) / phi;
}

float computeEdgeStoppingWeight(
                      float centerDepth,
                      float sampleDepth,
                      float phiZ,
                      vec3  centerNormal,
                      vec3  sampleNormal,
                      float phiNormal,
                      float centerLuma,
                      float sampleLuma,
                      float phiLuma)
{
    const float wZ      = depthEdgeStoppingWeight(centerDepth, sampleDepth, phiZ);
    const float wNormal = normalEdgeStoppingWeight(centerNormal, sampleNormal, phiNormal);
    const float wL      = lumaEdgeStoppingWeight(centerLuma, sampleLuma, phiLuma);
    const float w       = exp(0.0 - max(wL, 0.0) - max(wZ, 0.0)) * wNormal;
    return w;
}

float computeVarianceCenter(ivec2 ipos)
{
    float sum = 0.0f;

    const float kernel[2][2] = {
        { 1.0 / 4.0, 1.0 / 8.0 },
        { 1.0 / 8.0, 1.0 / 16.0 }
    };

    const int radius = 1;
    for (int yy = -radius; yy <= radius; yy++)
    {
        for (int xx = -radius; xx <= radius; xx++)
        {
            ivec2 p = ipos + ivec2(xx, yy);
            float k = kernel[abs(xx)][abs(yy)];
            sum += imageLoad(AccumulationImage, p).a * k;
        }
    }
    return sum;
}

void main() {
    ivec2 ipos = ivec2(gl_GlobalInvocationID.xy);

    vec4 gbuffer = imageLoad(GBufferImage, ipos);
    vec3 normal = gbuffer.xyz;
    float depth = gbuffer.w;

    const float epsVariance      = 1e-10;
    const float kernelWeights[3] = { 1.0, 2.0 / 3.0, 1.0 / 6.0 };

	const float   phiColorT   = 10.0f;
	const float   phiNormalT  = 32.f;
    const int radiusT    = 3;
    const int   stepSizeT  = 1;

    const vec4 centerColor = imageLoad(AccumulationImage, ipos);
    const float centerLuma = luminance(centerColor.rgb);
    const float var = computeVarianceCenter(ipos);

    const float phiColor = phiColorT * sqrt(max(0.0, var.r)) + epsVariance;

    float sumWeightColor = 1.0;
    vec4  sumColor = centerColor;

    // atrous core
    for (int yy = -radiusT; yy <= radiusT; yy++)
    {
        for (int xx = -radiusT; xx <= radiusT; xx++)
        {
            const ivec2 p = ipos + ivec2(xx, yy) * stepSizeT;
            // const bool  inside = all(greaterThanEqual(p, ivec2(0, 0))) && all(lessThan(p, size));
            // const float kernel = kernelWeights[abs(xx)] * kernelWeights[abs(yy)];

            // if (inside && (xx != 0 || yy != 0))
            // {
            //     const vec4 sampleColor = texelFetch(uInput, p, 0);
            //     const float sampleLuma = luminance(sampleColor.rgb);

            //     vec4 sampleNormal = texelFetch(uNormalSampler, p, 0);
            //     float depth = texelFetch(uPBRSampler, p, 0).a;

            //     // compute the edge-stopping functions
            //     const float w = computeEdgeStoppingWeight(centerDepth,
            //                                                  depth,
            //                                                  pushConstants.sigmaDepth,
            //                                                  octohedralToDirection(normal.xy),
            //                                                  octohedralToDirection(sampleNormal.xy),
            //                                                  pushConstants.phiNormal,
            //                                                  centerLuma,
            //                                                  sampleLuma,
            //                                                  phiColor);

            //     const float wVisibility = w * kernel;

            //     sumWeightColor += wVisibility;
            //     sumColor += vec4(vec3(wVisibility), wVisibility * wVisibility) * sampleColor;
            // }
        }
    }

    vec4 outColor = centerColor / Camera.TotalNumberOfSamples;
    imageStore(OutputImage, ipos, sqrt(outColor) );
}